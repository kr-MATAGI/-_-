1. Hash Table
	- 내부적으로 배열을 사용하여 데이터를 저장하기 때문에 빠른 검색 속도를 갖는다.
	- 특정한 값을 Search 하는데 데이터 고유의 인덱스로 접근하게 되므로
	 average case에 대하여 시간 복잡도가 O(1) 이 된다.
	  > 항상 O(1)이 아니고 average case에 대해서 O(1)인 것은 collision 때문)
	
	- 특별한 알고리즘(해시 함수)을 이용하여 저장할 데이터와 연관된 고유의 숫자를 만들어 낸 뒤 이를 인덱스로 사용한다.
	 > 특정한 데이터가 저장되는 인덱스에서는 그 데이터만의 고유한 위치이기 떄문에
	  삽입 연산 시 다른 데이터의 사이에 끼어들거나, 삭제 시 다른 데이터로 채울 필요가 없으므로 연산에서
	  추가적인 비용이 없도록 만들어진 구조
	
2. Hash Function
	- 이 함수에 의해 반환된 고유의 숫자 값을 hash code라고 한다.
	- 저장되는 값들의 key값을 hash function을 통해서 작은 범위의 값들로 바꾸어 준다.
	
	- 하지만 어설픈 해시 함수를 통해 key 값들을 설정한다면 동일한 값이 도출될 수 있다.
	 > 동일한 key 값에 복수 개의 데이터가 하나의 테이블에 존재할 수 있게 되는 현상을 Collision(충돌)이라 한다.
	 
	- 해시 함수의 조건
		> 해시 함수를 무조건 1:1 로 만드는 것보다 Collision 을 최소화 하는 방법으로 설계하고
		 발생하는 Collision에 대비해 어떻게 대응할 것인지가 더 중요하다.
		> 1:1 대응이 되도록 만드는것은 array와 다름없고 메모리를 매우 많이 차지한다.
		
		> Collision이 많을 수록 Search에 필요한 시간복잡도가 O(1)에서 O(n)에 가까워진다.
		
3. Collision 해결 방법
	1) Open Address(개방 주소법)
		- 해시 충돌이 발생하면 다른 해시 버킷에 해당 자료를 삽입하는 방식.
		- Collision이 발생하면 데잍를 저장할 장소를 찾는다.
		 Worst Case의 경우 비어있는 버킷을 찾지 못하고 탐색을 시작한 위치까지 되돌아 올 수 있다.
		
		- Linear Probing
			> 순차적으로 탐색하며 비어있는 버킷을 찾을 때까지 계속 진행한다.
		- Quadratic Probing
			> 2차 함수를 이용해 탐색할 위치를 찾는다
		- Double hashing Probing
			> 하나의 해쉬 함수에서 충돌이 발생한다면 2차 해쉬함수를 이용해 새로운 주소를 할당한다.
			> 위 2가지 방법에 비해 많은 연산량을 요구하게 된다.
			
	2) Separte Chaining(분리 연결법)
		- 개방 주소법은 분리 연결법 보다 느리다.
		- 개방 주소법의 경우 버킷을 채운 밀도가 높아질수록 Worst Case 발생 빈도가 높아진다.
		
		- 분리 연결법의 경우 해시 충돌이 잘 발생하지 않도록 보조 해시 함수를 통해 조정할 수 있다면
		 Worst Case에 가까워지는 빈도를 줄일 수 있다.
		- 분리 연결법을 구현하는 방법에는 2 가지가 있다.
			(1) 연결 리스트
				- 각각의 버킷들을 연결리스트로 만들어 충돌이 발생하면 해당 버킷의 리스트에 추가하는 방법
				- 연결 리스트의 특징을 그대로 사용하기에 삽입/삭제가 편리.
				- 작은 데이터들을 저장할 때 연결 리스트 자체의 오버헤드가 부담이 된다.
				- 버킷을 계속하는 개방 주소법에 비해 테이블의 확장을 늦출 수 있다.
			
			(2)	RBT를 사용하는 방식
				- 연결 리스트를 사용할 것인가와 트리를 사용할 것인가에 대한 기준은
				 하나의 해시버킷에 할당된 key-value 쌍의 개수이다.
				- 데이터 개수가 적다면 연결 리스트를 사용하는 것이 맞다.
				 > 트리는 기본적으로 메모리 사용량이 많기 때문이다.
				- 데이터 개수가 적을 때 Worst Case는 성능상 차이가 없다.
		