1. 메모리 관리
	- 각각의 프로세스는 독립된 메모리 공간을 가지고 있고, 운영체제 혹은 다른 프로세스의 메모리 공간에 접근할 수 없는 제한이 있다.
	- 운영체제만이 메모리 영역과 사용자 메모리 영역의 접근에 제약을 받지 않는다.

2. Swapping
	- 메모리의 관리를 위해 사용되는 기법.
	- 표준 Swapping 방식으로는 round-robin 과 같은 스케줄링의 다중 프로그래밍 환경에서
	 CPU 할당 시간이 끝난 프로세스의 메모리를 보조 기억장치(e.g 하드디스크)로 내보내고 다른 프로세스의 메모리를 불러 들일 수 있다.
	- swap에는 큰 디스크 전송시간이 필요하기 때문에 현재에는 메모리 공간이 부족할 때 Swapping이 시작된다.
		1) swap-in
			> 주 기억장치(RAM)으로 불러오는 과정
		2) swap-out
			> 보조 기억장치로 내보내는 과정
			
3. 단편화(Fragmentation)
	- 프로세스들이 메모리에 적재되고 제거되는 일이 반복되면 프로세스들이 차지하는 메모리 틈 사이에
	 사용하지 못할 만큼의 작은 자유 공간들이 늘어나게 되는 데, 이것이 단편화.
	 
	- 내부 단편화 ( 메모리 공간 > 프로세스 )
	- 외부 단편화
		> 메모리 공간 중 사용하지 못하는 일부분. (분산되어 있는 잉여 공간)
		
4. 페이징(Paging)
	- 하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리 방법.
	- 외부 단편화와 압축 작업을 해소하기 위해 생긴 방법
	- 물리 메모리는 Frame으로 분리되어 있고 논리 메모리(프로세스가 점유하는)는 페이지 라고 불리는 고정 크기의 블록으로 분리.
	
	- 논리 메모리는 물리 메모리에 저장될때, 연속으로 저장될 필요가 없고 물리 메모리의 남는 프레임에 적절히 배치되어
	 외부 단편화를 해결 할 수 있다.
	
	- 하나의 프로세스가 사용하는 공간은 여러 개의 페이지로 나뉘어서 관리되고,
	 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 mapping 되어 저장
	
	- 단점
		> 내부 단편화가 발생할 수 있다.
			1000B의 프레임 크기에서 프로세스 3001B가 할당될려면 총 4개의 페이지가 필요하나 마지막 페이지는 999B가 남음
			
5. 세그먼테이션(Segmentation)
	- 페이징에서 처럼 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌 서로 다른 크기의 논리적 단위인 세그먼트로 분할
	
	- 단점
		> 서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되다 보면, 자유 공간들이 많은 수의 작은 조각들로 나누어질 수 있다. (외부 단편화)
		