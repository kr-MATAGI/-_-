https://inpages.tistory.com/157

1. hello.c
	프로세서 (gcc -E -o tseti.i test.c)
2. hello.i
	컴파일러 (gcc -S -o test.s test.i)
3. hello.s
	어셈블러 (gcc -c -o test.o test.s)
4. hello.o
	링커	(gcc -g -o test test.o)
5. hello.out (executables)


*전처리기
	- 소스 코드의 주석을 제거, define을 치환하는 기능

* 컴파일러
	- 어셈블리 파일로 변환
	- 어셈블리 코드는 CPU 명령 조합
		> 어셈블리어는 CPU에 의존적
		
	1) front-end
		- 프로그래밍 언어를 처리
		- 소스 코드가 문법에 맞게 작성되었는지 분석
	* 어휘 분석
		> 소스 코드를 의미 있는 최소 단위 토큰으로 나눈다.
	* 구문 분석
		> 토큰으로 파스 트리를 생성하여 문법 오류를 검출
	* 의미 분석
		> 파스 트리를 이용해 의미상 오류가 있는지 검사한다.
		  (함수의 매개변수, 변수의 자료형, 값을 0으로 나누는지, 정수와 문자열을 더하는지)
	* 중간 코드 생성
		> 트리 형태의 중간 표현 GIMPLE Tree를 생성
		
	2) middle-end
		- 최적화를 수행한다.
		- 최적화는 대부분의 상용 컴파일러에서 이루어지고 있다.
	
	3) back-end
		- 최적화가 이루어지며 어셈블리 코드를 생성한다.

* 어셈블러
	- 오브젝트 코드 파일(목적 코드)로 변환
	- 오브젝트 코드는 0과 1로 이루어진 이진 코드
		> 바이너리 포맷 구조
	- 아직 주소 정보가 확정되지 않은 상태
	
* 링커
	- 오브젝트 파일들을 묶어서 실행 코드 파일로 변환.
	- 어셈블러에 의해 생성된 목적 코드 파일들과 이 프로그램에서 사용된 라이브러리들을 연결시키는 작업
	- printf()와 같은 함수에 대한 라이브러리가 연결된다.
	- 운영체제가 로딩할 수 있도록 주소 정보를 할당한 파일을 만들어 낸다.
		> 링커는 CPU에 의존적