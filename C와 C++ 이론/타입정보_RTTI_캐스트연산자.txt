1. RTTI (RunTime Type Information)
	- 실시간 정보 타입
	- 실행 중 타입에 대한 정보가 필요할 때 사용하는 기능.
		> 언어가 제공하는 표준이므로 호환성, 이식성이 확보되어 있다.
	
	- 가상 함수가 있는 클래스에 대해서만 동작한다.
		> 클래스의 타입 관련 정보가 vtable에 같이 저장되기 때문이다.
		> 가상 함수가 없는 클래스는 실행 중에 타입 정보를 알아야 할 필요가 없다.
		> 컴파일러는 컴파일 번역 작업이 끝나면 타입 이름을 실행파일에 남길 필요가 없어 RTTI로 정보를 가져온다.
	
	- RTTI가 제대로 동작하기 위해서는 모든 클래스에 타입과 관련된 정보를 작성해야한다.
		> 프로그램이 느려지고 용량이 커지는 문제가 있다.
		> 따라서 RTTI 기능을 사용할 것인지 아닌지에 대한 옵션 조정이 있다.
			(Visual Studio 기준 구성/속성 -> C/C++ -> 언어 -> 런타임 형식 정보 사용)
	
2. typeid 연산자
	- 클래스의 이름이나 객체 또는 객체를 가리키는 포인터를 피연산자로 취하며 피 연산자의 타입을 조사한다.
	- typeid를 사용하기 위해 typeinfo 헤더 파일을 포함한다 : #include <typeinfo>
	- 프로젝트 설정 대화상자 -> RTTI 옵션 선택
	- 형태 : typeid (자료형);
	- 리턴 타입 : const type_info &
	
	
3. 캐스트 연산자
	- C의 cast
		- 사용자의 요구대로 무조건 타입 변환 (부작용이 많다)
		- e.g) (변환타입)변수;
		
	- static_cast
		- 상속 관계 클래스 포인터 및 레퍼런스, 기본 타입, 타입 체크X
		- 지정한 타입을 무조건 변경하는게 아닌 논리적으로 변환 가능한 타입만 변환한다.
			* 실수형<->정수형
			  정수형<->실수형
			  상호 호환되는 열거형 <-> 정수형
		- 포인트 타입을 다른 것으로 변환하는 것은 허용되지 않는다.
			> 상속 관계에 있는 포인터끼리만 변환이 허용된다.
		- 상속 관계에서 다운 캐스팅은 캐스트 연산자의 도움 없이는 허가되지 않는다.
			> 업 캐스팅 : 상속 계층의 위쪽으로 이동하는 변환
			> 다운 캐스팅 : 상속 계층의 아래쪽으로 이동하는 변환, 부모가 자식의 모든 멤버를 가지지 않아 위험함
		e.g)
			static_cast<타입>(대상);
	
	- dynamic_cast
		- 상속 관계 클래스 포인터 및 래퍼런스, 타입 체크, RTTI 기능 필요
		- 포인터 끼리 또는 래퍼런스 끼리 변환하는 캐스트 연산자
			> 포인터는 포인터로, 레퍼런스는 레퍼런스로 변환해야 한다.
			> 포인터끼리 변환 시도 상속 계층에 속한 클래스끼리만 변환할 수 있다.
		
		* static_cast는 다운 캐스팅을 할 때 무조건 변환을 허가하지만
		 dynamic_cast는 실행 중에 타입을 점검하여 안전한 캐스팅만 한다.
		
		- dynamic_cast를 사용하기 위해 RTTI가 켜져있어야 하며, 하나 이상의 가상멤버함수를 가지고 있어야 한다.
		- 레퍼런ㅅ는 에러에 해당하는 NULL을 리턴할 수 없어 bad_cast 예외를 던지므로
		 try-catch 블록에 작성해서 bad_cast 예외를 처리해야한다.
		
		- 부모 타입의 포인터를 자식 타입의 포인터로 다운 캐스팅 할 때, 안전하다고 판단될 때만 변환한다.
			> int * -> char * // error
			> Parent * -> int * // error
		- 변환 대상 포인터가 부모 클래스형 포인터 타입인데 자식 객체를 가지고 있을 때
			> 자식 클래스형 포인터로 변환 가능 (실제로 가리키고 있는 객체의 타입대로 캐스팅)
		- 부모 클래스형 포인터가 부모 객체를 가리키고 있을 때, 자식 클래스로의 다운 캐스팅은 안된다.
		e.g)
			dynamic_cast<타입*>(대상);
		
	
	- const_cast
		- const, volatile, _ungligned 등의 속성 변경 (타입 X, 값 X)
		- 포인터의 상수성만 변경하고 싶을 때 사용하는 연산자
			> 상수 지시 포인터를 비상수 지시 포인터로 잠시 바꿀 수 있다.
			> 비상수 지시 포인터는 상수 지시 푄터로 항상 변환 가능하므로 캐스트 연산자가 필요 없다.
		- 포인터의 const 속성을 넣거나 빼거나 할 수 있다.
			> volatile 속성과 _ungligned 속성에 대해서도 변경할 수 있다.
		e.g)
			const_cast<타입*>(대상);
		- 정수를 실수 타입으로 변환하는 것은 상승 변화이지만, const_cast는 허용하지 않는다.
			> 자료형이나 값은 변경하지 못 한다.
			> const_cast는 오로지 포인터의 상수성만을 변경할 수 있다.
		
	- reinterpret_cast (재해석 캐스트 연산자)
		- 포인터 끼리, 포인터와 수치형간의 변환
		- 임의의 포인터 타입끼리 변환을 허용하는 위험한 캐스트 연산자.
		- 포인터 타입간의 변환이나 포인터와 수치형 데이터의 변환에만 사용한다.
			> 강제 변환이므로 상속 관계에 있지 않은 포인터끼리도 변환 가능하다.
			> 좌변은 무조건 포인터 타입이어야 한다.
			> 기본 타입으로 cast를 할 수 없다.
			> 기본 타입들끼리의 변환에는 사용할 수 없다.
		- 정수형과 포인터간의 변환도 허용한다. (포인터 <- 정수)
		- 정수형 값을 포인터 타입으로 바꾸어 절대 번지를 가리키도록 할 때 이 연산자를 사용한다.
			e.g)
				reinterpret_cast<타입 *>(대상);
	
	- reinterpret_cast