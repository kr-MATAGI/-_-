1. 변수 크기와 sizeof() 연산자
	- 메모리는 일반적으로 byte 단위로 구성되며, 각 단위는 고유한 주소를 가진다.
	- 변수는 보통 메모리를 1 byte 이상 차지한다.
	
	1) 변수가 더 많은 메모리를 차지할 수록 더 많은 정보를 저장할 수 있다.
		- 각 bit는 0 또는 1의 정보만을 가지기 때문에 1bit가 가질 수 있는 값의 경우의 수는 2개이다.
		 이와 같이 2bit가 가질수 있는 경우는 4개, 3비트는 8개이다.
	
	2) 컴퓨터가 사용 가능한 메모리양은 한정되어 있으므로, 자료형에 따른 변수의 크기가 중요하다.
	
2. C++ 기본 자료형의 크기
	- boolean -> 1 byte
	- character
		- char -> 1 byte
		- wchar_t -> 1 byte
		- char16_t -> 2 byte
		- char32_t -> 4 byte
	- integer
		- short -> 2 byte
		- int -> 2 byte
		- long -> 4 byte
		- long long -> 8 byte
	- floating point
		- float -> 4 byte
		- double -> 8 byte
		- long double -> 8 byte
	
3. sizeof()
	- 자료형 또는 변수를 가지고 크기는 byte 단위로 반환하는 연산자
	
	
4. 4 byte를 1 byte 씩 읽을 수 있는가
	- 읽을 수는 있을 것으로 보임. 메모리 상에서 4 byte의 공간을 차지하고 있을 뿐이지 주소상으로는 연속된 값임.
		- java의 read() : 1 byte씩 읽고 리턴값은 int(4 byte 중 1 byte만 데이터 저장)로 함. 읽은 byte를 리턴

5. 구조체의 크기
	- 멤버(기본 자료형) 중 제일 큰 변수의 메모리를 기준으로 잡아나간다.
	- RAM에 있는 데이터를 CPU의 레지스터(cpu의 메모리 공간)에 저장하며
	 레지스터에서 32비트는 4byte를, 64비트는 8byte를 한 번에 읽을 수 있다.
	- 레지스터에서 공간을 잡을 때는 비는 공간을 패딩 바이트(Padding Byte)라고 한다.
	- 비는 공간 중 비트 단위를 패딩비트(Padding Bit)라고 한다.
	- 클래스/구조체는 자신을 자신의 멤버로 가질 수 없다. (크기를 잴 때 무한 재귀가 발생)
	
6. 클래스의 메모리 크기
	- 멤버 중 제일 큰 변수의 메모리를 기준으로 레이아웃을 잡아나간다.
	- 구조체와 같이 제일 큰 함수의 크기만큼 공간을 잡는다. (변수의 순서에 상관 있다)
	- 레이아웃마다 제일 큰 공간으로 잡기에 메모리 낭비가 심하고 이를 #programa pack(1)으로 1 byte 단위로 할당할 수 있다.
	
	* 가상 함수를 가진 클래스
		- 가상함수를 가진 클래스는 멤버 변수 이외에 가상함수리스트(vtable)를 가리키는 포인터(vfptr)를 가진다.
		 (클래스 할당 시 제일 앞부분에 포인터(4byte)로 할당)
			> 때문에 가상 함수를 가진 클래스를 만들 때, 고려하고 만드는 것이 좋다.
		* vfptr은 가장 큰 메모리의 공간을 멤버 변수와 별개로 잡는다.
	 
	 
	
	
	